using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using PlatypusTools.UI.Utilities;

namespace PlatypusTools.UI.Services.Forensics
{
    /// <summary>
    /// Result of malware analysis for a single file.
    /// </summary>
    public class MalwareAnalysisResult
    {
        public string FileName { get; set; } = string.Empty;
        public string FilePath { get; set; } = string.Empty;
        public string FileType { get; set; } = string.Empty;
        public bool HasMacros { get; set; }
        public bool IsSuspicious { get; set; }
        public string? MacroDetails { get; set; }
        public List<string> Indicators { get; } = new();
    }

    /// <summary>
    /// Service for analyzing documents for malware using oletools and pdf-parser.
    /// Extracted from AdvancedForensicsViewModel for better modularity.
    /// </summary>
    public class MalwareAnalysisService : ForensicOperationBase
    {
        private static readonly string[] _officeExtensions = 
            { ".doc", ".docx", ".docm", ".xls", ".xlsx", ".xlsm", ".ppt", ".pptx", ".pptm" };
        private static readonly string[] _pdfExtensions = { ".pdf" };

        public override string OperationName => "Malware Analysis";

        /// <summary>
        /// Path to oletools (olevba, mraptor).
        /// </summary>
        public string? OletoolsPath { get; set; }

        /// <summary>
        /// Path to pdf-parser.py.
        /// </summary>
        public string? PdfParserPath { get; set; }

        /// <summary>
        /// Whether to run olevba for VBA extraction.
        /// </summary>
        public bool RunOlevba { get; set; } = true;

        /// <summary>
        /// Whether to run mraptor for auto-exec detection.
        /// </summary>
        public bool RunMraptor { get; set; } = true;

        /// <summary>
        /// Whether to analyze PDFs.
        /// </summary>
        public bool RunPdfParser { get; set; } = true;

        /// <summary>
        /// Analyzes documents in a folder for malware.
        /// </summary>
        public async Task<List<MalwareAnalysisResult>> AnalyzeFolderAsync(
            string folderPath,
            CancellationToken cancellationToken = default)
        {
            var results = new List<MalwareAnalysisResult>();

            await ExecuteWithHandlingAsync(async (token) =>
            {
                if (!Directory.Exists(folderPath))
                {
                    LogError($"Folder not found: {folderPath}");
                    return;
                }

                LogHeader("Malware Analysis");
                Log($"Folder: {folderPath}");
                Log($"oletools: {(string.IsNullOrEmpty(OletoolsPath) ? "Using system PATH" : OletoolsPath)}");
                Log($"pdf-parser: {(File.Exists(PdfParserPath) ? "Available" : "Not configured")}");
                Log("");

                // Get all relevant files using async enumeration
                var allExtensions = _officeExtensions.Concat(_pdfExtensions).ToArray();
                var files = await AsyncFileEnumerator.GetFilesAsync(folderPath, allExtensions, cancellationToken: token);

                Log($"Found {files.Count} documents to analyze");
                Log("");

                int processed = 0;
                foreach (var file in files)
                {
                    token.ThrowIfCancellationRequested();

                    StatusMessage = $"Analyzing: {Path.GetFileName(file)}";
                    Log($"[{processed + 1}/{files.Count}] {Path.GetFileName(file)}");

                    var ext = Path.GetExtension(file).ToLowerInvariant();
                    MalwareAnalysisResult? result = null;

                    if (_officeExtensions.Contains(ext))
                    {
                        result = await AnalyzeOfficeDocumentAsync(file, token);
                    }
                    else if (_pdfExtensions.Contains(ext))
                    {
                        result = await AnalyzePdfDocumentAsync(file, token);
                    }

                    if (result != null)
                    {
                        results.Add(result);
                        if (result.IsSuspicious)
                        {
                            LogWarning($"  âš  SUSPICIOUS: {string.Join(", ", result.Indicators)}");
                        }
                    }

                    processed++;
                    UpdateProgress(processed, files.Count);
                }

                Log("");
                LogHeader("Analysis Summary");
                var suspicious = results.Count(r => r.IsSuspicious);
                var withMacros = results.Count(r => r.HasMacros);
                Log($"Files analyzed: {processed}");
                Log($"Files with macros: {withMacros}");
                Log($"Suspicious files: {suspicious}");

                if (suspicious > 0)
                {
                    LogWarning($"Found {suspicious} suspicious file(s)!");
                }
                else
                {
                    LogSuccess("No suspicious files detected");
                }
            });

            return results;
        }

        private async Task<MalwareAnalysisResult> AnalyzeOfficeDocumentAsync(string filePath, CancellationToken token)
        {
            var result = new MalwareAnalysisResult
            {
                FileName = Path.GetFileName(filePath),
                FilePath = filePath,
                FileType = Path.GetExtension(filePath).TrimStart('.').ToUpperInvariant()
            };

            // Run olevba
            if (RunOlevba)
            {
                var olevbaOutput = await RunToolAsync("olevba", $"-a \"{filePath}\"", token);
                if (!string.IsNullOrEmpty(olevbaOutput))
                {
                    result.HasMacros = olevbaOutput.Contains("VBA MACRO") || 
                                       olevbaOutput.Contains("OLE");
                    result.MacroDetails = olevbaOutput;

                    // Check for suspicious patterns
                    var suspiciousPatterns = new[]
                    {
                        "AutoOpen", "AutoExec", "Document_Open", "Workbook_Open",
                        "Shell", "WScript.Shell", "PowerShell", "cmd.exe",
                        "CreateObject", "GetObject", "CallByName",
                        "URLDownloadToFile", "XMLHTTP", "MSXML2",
                        "Base64", "Chr(", "Environ("
                    };

                    foreach (var pattern in suspiciousPatterns)
                    {
                        if (olevbaOutput.Contains(pattern, StringComparison.OrdinalIgnoreCase))
                        {
                            result.Indicators.Add(pattern);
                        }
                    }
                }
            }

            // Run mraptor
            if (RunMraptor)
            {
                var mraptorOutput = await RunToolAsync("mraptor", $"\"{filePath}\"", token);
                if (!string.IsNullOrEmpty(mraptorOutput))
                {
                    if (mraptorOutput.Contains("SUSPICIOUS", StringComparison.OrdinalIgnoreCase) ||
                        mraptorOutput.Contains("Match", StringComparison.OrdinalIgnoreCase))
                    {
                        result.Indicators.Add("AutoExec-Macro");
                    }
                }
            }

            result.IsSuspicious = result.Indicators.Count > 0;
            return result;
        }

        private async Task<MalwareAnalysisResult> AnalyzePdfDocumentAsync(string filePath, CancellationToken token)
        {
            var result = new MalwareAnalysisResult
            {
                FileName = Path.GetFileName(filePath),
                FilePath = filePath,
                FileType = "PDF"
            };

            if (!RunPdfParser || string.IsNullOrEmpty(PdfParserPath) || !File.Exists(PdfParserPath))
            {
                return result;
            }

            var output = await RunToolAsync("python", $"\"{PdfParserPath}\" --stats \"{filePath}\"", token);
            if (!string.IsNullOrEmpty(output))
            {
                // Check for suspicious PDF elements
                var suspiciousElements = new[]
                {
                    "/JavaScript", "/JS", "/Launch", "/EmbeddedFile",
                    "/OpenAction", "/AA", "/AcroForm", "/XFA",
                    "/ObjStm", "/URI", "/SubmitForm"
                };

                foreach (var element in suspiciousElements)
                {
                    if (output.Contains(element, StringComparison.OrdinalIgnoreCase))
                    {
                        result.Indicators.Add(element);
                    }
                }
            }

            result.IsSuspicious = result.Indicators.Count > 0;
            return result;
        }

        private async Task<string> RunToolAsync(string tool, string arguments, CancellationToken token)
        {
            try
            {
                var psi = new ProcessStartInfo
                {
                    FileName = tool,
                    Arguments = arguments,
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true
                };

                using var process = new Process { StartInfo = psi };
                process.Start();

                var output = await process.StandardOutput.ReadToEndAsync(token);
                await process.WaitForExitAsync(token);

                return output;
            }
            catch (Exception)
            {
                return string.Empty;
            }
        }

        /// <summary>
        /// Installs oletools via pip.
        /// </summary>
        public async Task<bool> InstallOletoolsAsync(CancellationToken cancellationToken = default)
        {
            LogHeader("Installing oletools");
            
            try
            {
                var psi = new ProcessStartInfo
                {
                    FileName = "pip",
                    Arguments = "install oletools --upgrade",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true
                };

                using var process = new Process { StartInfo = psi };
                process.Start();

                var output = await process.StandardOutput.ReadToEndAsync(cancellationToken);
                await process.WaitForExitAsync(cancellationToken);

                if (process.ExitCode == 0)
                {
                    LogSuccess("oletools installed successfully");
                    Log("  Tools available: olevba, mraptor, oleid, olemeta");
                    return true;
                }
                else
                {
                    LogError($"Installation failed (exit code: {process.ExitCode})");
                    return false;
                }
            }
            catch (Exception ex)
            {
                LogError($"Installation failed: {ex.Message}");
                Log("  Make sure Python and pip are installed and in PATH");
                return false;
            }
        }
    }
}
